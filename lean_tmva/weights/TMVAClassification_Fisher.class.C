// Class: ReadFisher
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : Fisher::Fisher
TMVA Release   : 4.1.4         [262404]
ROOT Release   : 5.34/09       [336393]
Creator        : inutard
Date           : Mon Jan 13 21:22:11 2014
Host           : Linux panlong 3.2.0-37-generic #58-Ubuntu SMP Thu Jan 24 15:28:10 UTC 2013 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /home/inutard/Desktop/tmva-studies/lean_tmva
Training events: 23465
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
H: "True" [Print method-specific help message]
CreateMVAPdfs: "True" [Create PDFs for classifier outputs (signal and background)]
Method: "Fisher" [Discrimination method]
# Default:
VerbosityLevel: "Default" [Verbosity level]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 42
(Ht>2500e3)?2500e3:Ht         _Ht_2500e3__2500e3:Ht         (Ht>2500e3)?2500e3:Ht         Ht                            MeV                               'F'    [509029.90625,2500000]
(b_had_pt>700e3)?700e3:b_had_pt _b_had_pt_700e3__700e3:b_had_pt (b_had_pt>700e3)?700e3:b_had_pt Pt(b_had)                       MeV                                 'F'    [25006.7910156,700000]
(b_lep_pt>700e3)?700e3:b_lep_pt _b_lep_pt_700e3__700e3:b_lep_pt (b_lep_pt>700e3)?700e3:b_lep_pt Pt(b_lep)                       MeV                                 'F'    [25007.9375,700000]
lep_pt                        lep_pt                        lep_pt                        lep_pt                        nan                               'F'    [20007.3261719,1097042.25]
lep_eta                       lep_eta                       lep_eta                       lep_eta                       nan                               'F'    [-2.47533321381,2.4819419384]
lep_phi                       lep_phi                       lep_phi                       lep_phi                       nan                               'F'    [-3.14132118225,3.14153909683]
met_et                        met_et                        met_et                        met_et                        nan                               'F'    [988.338867188,1212683.875]
met_phi                       met_phi                       met_phi                       met_phi                       nan                               'F'    [-3.14142751694,3.14110827446]
jet_n                         jet_n                         jet_n                         jet_n                         nan                               'i'    [3,14]
jet_m_max                     jet_m_max                     jet_m_max                     jet_m_max                     nan                               'F'    [60000.265625,179855.5625]
n_btags_70                    n_btags_70                    n_btags_70                    n_btags_70                    nan                               'I'    [0,5]
mwt                           mwt                           mwt                           mwt                           nan                               'F'    [6.92663526535,1539711.625]
Whad_pt                       Whad_pt                       Whad_pt                       Whad_pt                       nan                               'F'    [250003.984375,1428809]
Whad_eta                      Whad_eta                      Whad_eta                      Whad_eta                      nan                               'F'    [-2.33010792732,2.25264978409]
Whad_phi                      Whad_phi                      Whad_phi                      Whad_phi                      nan                               'F'    [-3.14123415947,3.14146661758]
Whad_m                        Whad_m                        Whad_m                        Whad_m                        nan                               'F'    [60000.265625,109937.414062]
Whad_dR                       Whad_dR                       Whad_dR                       Whad_dR                       nan                               'F'    [-1,0.772672593594]
Wlep_pt                       Wlep_pt                       Wlep_pt                       Wlep_pt                       nan                               'F'    [1296.06591797,1374306.875]
Wlep_eta                      Wlep_eta                      Wlep_eta                      Wlep_eta                      nan                               'F'    [-4.75985717773,6.55746221542]
Wlep_phi                      Wlep_phi                      Wlep_phi                      Wlep_phi                      nan                               'F'    [-3.13974118233,3.14140701294]
Wlep_m                        Wlep_m                        Wlep_m                        Wlep_m                        nan                               'F'    [80394.3984375,1539711.625]
b_lep_pt                      b_lep_pt                      b_lep_pt                      b_lep_pt                      nan                               'F'    [25007.9375,1307815.875]
b_had_pt                      b_had_pt                      b_had_pt                      b_had_pt                      nan                               'F'    [25006.7910156,1480084]
tprime_lep_pt                 tprime_lep_pt                 tprime_lep_pt                 tprime_lep_pt                 nan                               'F'    [5714.87841797,1496589.375]
tprime_had_pt                 tprime_had_pt                 tprime_had_pt                 tprime_had_pt                 nan                               'F'    [4196.60595703,1438302.875]
dR_lnu                        dR_lnu                        dR_lnu                        dR_lnu                        nan                               'F'    [0.118681840599,4.50309705734]
dR_lb_lep                     dR_lb_lep                     dR_lb_lep                     dR_lb_lep                     nan                               'F'    [0.400214612484,5.07148122787]
dR_lb_had                     dR_lb_had                     dR_lb_had                     dR_lb_had                     nan                               'F'    [0.401370584965,5.1140370369]
dR_lb1                        dR_lb1                        dR_lb1                        dR_lb1                        nan                               'F'    [0.400214612484,4.93675470352]
dR_lb2                        dR_lb2                        dR_lb2                        dR_lb2                        nan                               'F'    [0.40218693018,5.1140370369]
dR_Wlep_blep                  dR_Wlep_blep                  dR_Wlep_blep                  dR_Wlep_blep                  nan                               'F'    [0.0196545533836,7.90818357468]
dR_Whad_blep                  dR_Whad_blep                  dR_Whad_blep                  dR_Whad_blep                  nan                               'F'    [0.396414637566,5.52754449844]
dR_Whad_bhad                  dR_Whad_bhad                  dR_Whad_bhad                  dR_Whad_bhad                  nan                               'F'    [0.397040575743,4.7444434166]
dR_Whad_b1                    dR_Whad_b1                    dR_Whad_b1                    dR_Whad_b1                    nan                               'F'    [0.396414637566,4.7444434166]
dR_Whad_b2                    dR_Whad_b2                    dR_Whad_b2                    dR_Whad_b2                    nan                               'F'    [0.399091243744,5.52754449844]
mindR_Whad_b                  mindR_Whad_b                  mindR_Whad_b                  mindR_Whad_b                  nan                               'F'    [0.396414637566,4.25239944458]
mindR_lb                      mindR_lb                      mindR_lb                      mindR_lb                      nan                               'F'    [0.400214612484,4.26060628891]
mindR_jj                      mindR_jj                      mindR_jj                      mindR_jj                      nan                               'F'    [0.380293309689,3.63540410995]
mindR_lj                      mindR_lj                      mindR_lj                      mindr_lj                      nan                               'F'    [0.400214612484,3.63768362999]
Mjj_hpt                       Mjj_hpt                       Mjj_hpt                       Mjj_hpt                       nan                               'F'    [63800.75,2115952.5]
Ht                            Ht                            Ht                            Ht                            nan                               'F'    [509029.90625,3296757.25]
m_reco                        m_reco                        m_reco                        m_reco                        nan                               'F'    [75616.296875,1807815.875]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadFisher : public IClassifierReader {

 public:

   // constructor
   ReadFisher( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadFisher" ),
        fNvars( 42 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "(Ht>2500e3)?2500e3:Ht", "(b_had_pt>700e3)?700e3:b_had_pt", "(b_lep_pt>700e3)?700e3:b_lep_pt", "lep_pt", "lep_eta", "lep_phi", "met_et", "met_phi", "jet_n", "jet_m_max", "n_btags_70", "mwt", "Whad_pt", "Whad_eta", "Whad_phi", "Whad_m", "Whad_dR", "Wlep_pt", "Wlep_eta", "Wlep_phi", "Wlep_m", "b_lep_pt", "b_had_pt", "tprime_lep_pt", "tprime_had_pt", "dR_lnu", "dR_lb_lep", "dR_lb_had", "dR_lb1", "dR_lb2", "dR_Wlep_blep", "dR_Whad_blep", "dR_Whad_bhad", "dR_Whad_b1", "dR_Whad_b2", "mindR_Whad_b", "mindR_lb", "mindR_jj", "mindR_lj", "Mjj_hpt", "Ht", "m_reco" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 509029.90625;
      fVmax[0] = 2500000;
      fVmin[1] = 25006.791015625;
      fVmax[1] = 700000;
      fVmin[2] = 25007.9375;
      fVmax[2] = 700000;
      fVmin[3] = 20007.326171875;
      fVmax[3] = 1097042.25;
      fVmin[4] = -2.47533321380615;
      fVmax[4] = 2.48194193840027;
      fVmin[5] = -3.14132118225098;
      fVmax[5] = 3.14153909683228;
      fVmin[6] = 988.3388671875;
      fVmax[6] = 1212683.875;
      fVmin[7] = -3.14142751693726;
      fVmax[7] = 3.14110827445984;
      fVmin[8] = 3;
      fVmax[8] = 14;
      fVmin[9] = 60000.265625;
      fVmax[9] = 179855.5625;
      fVmin[10] = 0;
      fVmax[10] = 5;
      fVmin[11] = 6.92663526535034;
      fVmax[11] = 1539711.625;
      fVmin[12] = 250003.984375;
      fVmax[12] = 1428809;
      fVmin[13] = -2.33010792732239;
      fVmax[13] = 2.25264978408813;
      fVmin[14] = -3.1412341594696;
      fVmax[14] = 3.14146661758423;
      fVmin[15] = 60000.265625;
      fVmax[15] = 109937.4140625;
      fVmin[16] = -1;
      fVmax[16] = 0.772672593593597;
      fVmin[17] = 1296.06591796875;
      fVmax[17] = 1374306.875;
      fVmin[18] = -4.75985717773438;
      fVmax[18] = 6.55746221542358;
      fVmin[19] = -3.13974118232727;
      fVmax[19] = 3.14140701293945;
      fVmin[20] = 80394.3984375;
      fVmax[20] = 1539711.625;
      fVmin[21] = 25007.9375;
      fVmax[21] = 1307815.875;
      fVmin[22] = 25006.791015625;
      fVmax[22] = 1480084;
      fVmin[23] = 5714.87841796875;
      fVmax[23] = 1496589.375;
      fVmin[24] = 4196.60595703125;
      fVmax[24] = 1438302.875;
      fVmin[25] = 0.118681840598583;
      fVmax[25] = 4.50309705734253;
      fVmin[26] = 0.400214612483978;
      fVmax[26] = 5.07148122787476;
      fVmin[27] = 0.401370584964752;
      fVmax[27] = 5.11403703689575;
      fVmin[28] = 0.400214612483978;
      fVmax[28] = 4.93675470352173;
      fVmin[29] = 0.402186930179596;
      fVmax[29] = 5.11403703689575;
      fVmin[30] = 0.0196545533835888;
      fVmax[30] = 7.90818357467651;
      fVmin[31] = 0.396414637565613;
      fVmax[31] = 5.5275444984436;
      fVmin[32] = 0.397040575742722;
      fVmax[32] = 4.74444341659546;
      fVmin[33] = 0.396414637565613;
      fVmax[33] = 4.74444341659546;
      fVmin[34] = 0.399091243743896;
      fVmax[34] = 5.5275444984436;
      fVmin[35] = 0.396414637565613;
      fVmax[35] = 4.25239944458008;
      fVmin[36] = 0.400214612483978;
      fVmax[36] = 4.26060628890991;
      fVmin[37] = 0.380293309688568;
      fVmax[37] = 3.63540410995483;
      fVmin[38] = 0.400214612483978;
      fVmax[38] = 3.63768362998962;
      fVmin[39] = 63800.75;
      fVmax[39] = 2115952.5;
      fVmin[40] = 509029.90625;
      fVmax[40] = 3296757.25;
      fVmin[41] = 75616.296875;
      fVmax[41] = 1807815.875;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'i';
      fType[9] = 'F';
      fType[10] = 'I';
      fType[11] = 'F';
      fType[12] = 'F';
      fType[13] = 'F';
      fType[14] = 'F';
      fType[15] = 'F';
      fType[16] = 'F';
      fType[17] = 'F';
      fType[18] = 'F';
      fType[19] = 'F';
      fType[20] = 'F';
      fType[21] = 'F';
      fType[22] = 'F';
      fType[23] = 'F';
      fType[24] = 'F';
      fType[25] = 'F';
      fType[26] = 'F';
      fType[27] = 'F';
      fType[28] = 'F';
      fType[29] = 'F';
      fType[30] = 'F';
      fType[31] = 'F';
      fType[32] = 'F';
      fType[33] = 'F';
      fType[34] = 'F';
      fType[35] = 'F';
      fType[36] = 'F';
      fType[37] = 'F';
      fType[38] = 'F';
      fType[39] = 'F';
      fType[40] = 'F';
      fType[41] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadFisher() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[42];
   double fVmax[42];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[42];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   double              fFisher0;
   std::vector<double> fFisherCoefficients;
};

inline void ReadFisher::Initialize() 
{
   fFisher0 = -2.70270749579;
   fFisherCoefficients.push_back( 1.49435597926e-06 );
   fFisherCoefficients.push_back( 2.26740791749e-06 );
   fFisherCoefficients.push_back( 3.78826895882e-06 );
   fFisherCoefficients.push_back( 5.81153725301e-07 );
   fFisherCoefficients.push_back( -0.0389382098706 );
   fFisherCoefficients.push_back( -0.0142871170207 );
   fFisherCoefficients.push_back( 1.50627409243e-07 );
   fFisherCoefficients.push_back( -0.0120557577174 );
   fFisherCoefficients.push_back( 0.0683529880151 );
   fFisherCoefficients.push_back( 2.50696086914e-06 );
   fFisherCoefficients.push_back( 0.241194793808 );
   fFisherCoefficients.push_back( 5.17844226845e-07 );
   fFisherCoefficients.push_back( -1.14576812239e-07 );
   fFisherCoefficients.push_back( 0.00450092962216 );
   fFisherCoefficients.push_back( -0.00235196964237 );
   fFisherCoefficients.push_back( 5.27722806785e-06 );
   fFisherCoefficients.push_back( -0.26934418419 );
   fFisherCoefficients.push_back( -5.99383321202e-07 );
   fFisherCoefficients.push_back( 0.0472935348486 );
   fFisherCoefficients.push_back( 0.0291236440165 );
   fFisherCoefficients.push_back( 1.63768208203e-06 );
   fFisherCoefficients.push_back( -2.8523319122e-06 );
   fFisherCoefficients.push_back( -1.44344448211e-06 );
   fFisherCoefficients.push_back( 3.61628017298e-07 );
   fFisherCoefficients.push_back( -3.02500035989e-07 );
   fFisherCoefficients.push_back( -0.419192058441 );
   fFisherCoefficients.push_back( -0.143488796052 );
   fFisherCoefficients.push_back( -0.211522813487 );
   fFisherCoefficients.push_back( 0.262486604887 );
   fFisherCoefficients.push_back( 0.232663458022 );
   fFisherCoefficients.push_back( 0.0991629814975 );
   fFisherCoefficients.push_back( 0.182671587419 );
   fFisherCoefficients.push_back( 0.256773193998 );
   fFisherCoefficients.push_back( -0.291657082157 );
   fFisherCoefficients.push_back( -0.306063152694 );
   fFisherCoefficients.push_back( 0.202637719845 );
   fFisherCoefficients.push_back( 0.0175448700505 );
   fFisherCoefficients.push_back( -0.00111791434354 );
   fFisherCoefficients.push_back( 0.1413241444 );
   fFisherCoefficients.push_back( 2.48015223996e-07 );
   fFisherCoefficients.push_back( -1.11243647453e-06 );
   fFisherCoefficients.push_back( 3.04981870809e-07 );

   // sanity check
   if (fFisherCoefficients.size() != fNvars) {
      std::cout << "Problem in class \"" << fClassName << "\"::Initialize: mismatch in number of input values"
                << fFisherCoefficients.size() << " != " << fNvars << std::endl;
      fStatusIsClean = false;
   }         
}

inline double ReadFisher::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double retval = fFisher0;
   for (size_t ivar = 0; ivar < fNvars; ivar++) {
      retval += fFisherCoefficients[ivar]*inputValues[ivar];
   }

   return retval;
}

// Clean up
inline void ReadFisher::Clear() 
{
   // clear coefficients
   fFisherCoefficients.clear(); 
}
   inline double ReadFisher::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
